#include <inttypes.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "encode.h"


// Translation tables from codepage bytes to unicode code point
static uint32_t koi8_r[] = {
    0x2500, 0x2502, 0x250c, 0x2510, 0x2514, 0x2518, 0x251c, 0x2524, 0x252c, 0x2534, 0x253c, 0x2580, 0x2584, 0x2588, 0x258c, 0x2590,
    0x2591, 0x2592, 0x2593, 0x2320, 0x25a0, 0x2219, 0x221a, 0x2248, 0x2264, 0x2265, 0xa0,   0x2321, 0xb0,   0xb2,   0xb7,   0xf7,
    0x2550, 0x2551, 0x2552, 0x0451, 0x2553, 0x2554, 0x2555, 0x2556, 0x2557, 0x2558, 0x2559, 0x255a, 0x255b, 0x255c, 0x255d, 0x255e,
    0x255f, 0x2560, 0x2561, 0x0401, 0x2562, 0x2563, 0x2564, 0x2565, 0x2566, 0x2567, 0x2568, 0x2569, 0x256a, 0x256b, 0x256c, 0xa9,
    0x044e, 0x0430, 0x0431, 0x0446, 0x0434, 0x0435, 0x0444, 0x0433, 0x0445, 0x0438, 0x0439, 0x043a, 0x043b, 0x043c, 0x043d, 0x043e,
    0x043f, 0x044f, 0x0440, 0x0441, 0x0442, 0x0443, 0x0436, 0x0432, 0x044c, 0x044b, 0x0437, 0x0448, 0x044d, 0x0449, 0x0447, 0x044a,
    0x042e, 0x0410, 0x0411, 0x0426, 0x0414, 0x0415, 0x0424, 0x0413, 0x0425, 0x0418, 0x0419, 0x041a, 0x041b, 0x041c, 0x041d, 0x041e,
    0x041f, 0x042f, 0x0420, 0x0421, 0x0422, 0x0423, 0x0416, 0x0412, 0x042c, 0x042b, 0x0417, 0x0428, 0x042d, 0x0429, 0x0427, 0x042a
};

static uint32_t cp1251[] = {
    0x0402, 0x0403, 0x201a, 0x0453, 0x201e, 0x2026, 0x2020, 0x2021, 0x20ac, 0x2030, 0x0409, 0x2039, 0x040a, 0x040c, 0x040b, 0x040f,
    0x0452, 0x2018, 0x2019, 0x201c, 0x201d, 0x2022, 0x2013, 0x2014, 0xfffe, 0x2122, 0x0459, 0x203a, 0x045a, 0x045c, 0x045b, 0x045f,
    0xa0,   0x040e, 0x045e, 0x0408, 0xa4,   0x0490, 0xa6,   0xa7,   0x0401, 0xa9,   0x0404, 0xab,   0xac,   0xad,   0xae,   0x0407,
    0xb0,   0xb1,   0x0406, 0x0456, 0x0491, 0xb5,   0xb6,   0xb7,   0x0451, 0x2116, 0x0454, 0xbb,   0x0458, 0x0405, 0x0455, 0x0457,
    0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419, 0x041a, 0x041b, 0x041c, 0x041d, 0x041e, 0x041f,
    0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 0x0429, 0x042a, 0x042b, 0x042c, 0x042d, 0x042e, 0x042f,
    0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437, 0x0438, 0x0439, 0x043a, 0x043b, 0x043c, 0x043d, 0x043e, 0x043f,
    0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447, 0x0448, 0x0449, 0x044a, 0x044b, 0x044c, 0x044d, 0x044e, 0x044f
};

static uint32_t iso_8859_5[] = {
    0x80,   0x81,   0x82,   0x83,   0x84,   0x85,   0x86,   0x87,   0x88,   0x89,   0x8a,   0x8b,   0x8c,   0x8d,   0x8e,   0x8f,
    0x90,   0x91,   0x92,   0x93,   0x94,   0x95,   0x96,   0x97,   0x98,   0x99,   0x9a,   0x9b,   0x9c,   0x9d,   0x9e,   0x9f,
    0xa0,   0x0401, 0x0402, 0x0403, 0x0404, 0x0405, 0x0406, 0x0407, 0x0408, 0x0409, 0x040a, 0x040b, 0x040c, 0xad,   0x040e, 0x040f,
    0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419, 0x041a, 0x041b, 0x041c, 0x041d, 0x041e, 0x041f,
    0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 0x0429, 0x042a, 0x042b, 0x042c, 0x042d, 0x042e, 0x042f,
    0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437, 0x0438, 0x0439, 0x043a, 0x043b, 0x043c, 0x043d, 0x043e, 0x043f,
    0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447, 0x0448, 0x0449, 0x044a, 0x044b, 0x044c, 0x044d, 0x044e, 0x044f,
    0x2116, 0x0451, 0x0452, 0x0453, 0x0454, 0x0455, 0x0456, 0x0457, 0x0458, 0x0459, 0x045a, 0x045b, 0x045c, 0xa7,   0x045e, 0x045f
};

typedef struct encoding_
{
    char *encoding_name;
    uint32_t *encoding_data;
} encoding_t;

static encoding_t supported_encodings[] = {
    {"koi8-r", koi8_r},
    {"cp1251", cp1251},
    {"iso-8859-5", iso_8859_5},
    {0}
};

void print_supported_encodings(void)
{
    printf("Supported encodings:\n");
    for (encoding_t *e = supported_encodings; e->encoding_name; ++e)
    {
        printf("\t%s\n", e->encoding_name);
    }
}

encoding_t* get_encoding_data(char *encoding_name)
{
    for (encoding_t *e = supported_encodings; e->encoding_name; ++e)
    {
        if (!strcmp(encoding_name, e->encoding_name))
        {
            return e;
        }
    }
    return NULL;
}


typedef struct utf8_
{
    uint8_t mask;
    uint8_t start;
    uint32_t start_range;
    uint32_t end_range;
} utf8_t;

static utf8_t utf[] = {
  // 01111111 00000000
    {0x7f,    0x00,  0x0000,   0x007f},  // 1 byte  needs
  // 00011111 11000000
    {0x1f,    0xc0,  0x0080,   0x07ff},  // 2 bytes need
  // 00001111 11100000
    {0x0f,    0xe0,  0x0800,   0xffff},  // 3 bytes need
  // 00000111 11110000
    {0x07,    0xf0, 0x10000, 0x10ffff},  // 4 bytes need
    {0}
};

#define BASE_MASK  0x3f  // 00111111
#define BASE_START 0x80  // 10000000
#define BASE_BITS  6

// uses this code if number of required bytes suddenly more 4 - '?'
#define CHANGE_SYMBOL 0x3f


static size_t bytes_required(uint32_t cp)
{
    int number = 1;
    for (utf8_t *u = utf; u->mask; ++u)
    {
        if ((cp >= u->start_range) && (cp <= u->end_range))
        {
            return number;
        }
        number++;
    }
    return 0;
}

#define READ_BLOCK_SIZE 128*1024
int encode(FILE *in, FILE *out, encoding_t *enc)
{
    int result = 0;
    char *read_buff;

    read_buff = malloc(READ_BLOCK_SIZE);
    if (!read_buff)
    {
        result = 1;
        goto cleanup;
    }

    while (!feof(in))
    {
        size_t read_count = fread(
            read_buff,
            sizeof(unsigned char),
            READ_BLOCK_SIZE,
            in
        );
        if (ferror(in))
        {
            result = 1;
            perror("Read error");
            goto cleanup;
        }

        uint8_t byte_to_encode;
        uint32_t cp;
        size_t encoded_len;
        unsigned char encoded[sizeof(utf)/sizeof(utf8_t)];

        for (size_t i = 0; i < read_count; i++)
        {
            byte_to_encode = read_buff[i];
            if (byte_to_encode < BASE_START)
            {
                cp = byte_to_encode;
            }
            else
            {
                cp = enc->encoding_data[byte_to_encode - BASE_START];
            }

            encoded_len = bytes_required( cp );
            if (!encoded_len)
            {
                encoded_len = bytes_required(CHANGE_SYMBOL);
            }

            int shift = BASE_BITS * (encoded_len - 1);
            encoded[0] = (cp >> shift & utf[encoded_len - 1].mask) |
                          utf[encoded_len - 1].start;

            shift -= BASE_BITS;
            for (size_t i = 1; i < encoded_len; ++i)
            {
                encoded[i] = (cp >> shift & BASE_MASK) | BASE_START;
                shift -= BASE_BITS;
            }

            fwrite(encoded, 1, encoded_len, out);
            if (ferror(out))
            {
                result = 1;
                perror("Write error");
                goto cleanup;
            }
        }
    }

cleanup:
    free(read_buff);
    return result;
}
